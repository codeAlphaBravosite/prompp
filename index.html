<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Library</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    <!-- PWA / Favicon Assets: These files (icon-192x192.png, manifest.webmanifest) -->
    <!-- must be present in the same directory as this HTML file for PWA features to work. -->
    <link rel="icon" href="./icon-192x192.png" type="image/png">
    <link rel="shortcut icon" href="./icon-192x192.png" type="image/png">
    <link rel="apple-touch-icon" href="./icon-192x192.png">
    <link rel="manifest" href="./manifest.webmanifest">

    <style>
        /* --- START OF style.css --- */
        :root {
            --font-family-sans-serif: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --background-color: #F4F7FC;
            --card-background-color: #FFFFFF;
            --text-color-primary: #333D48;
            --text-color-secondary: #7A869A;
            --accent-color: #4A90E2; /* A pleasant blue */
            --accent-color-darker: #3A7BC8;
            --danger-color: #E74C3C; /* Red for delete/errors */
            --danger-color-darker: #C0392B;
            --success-color: #28A745; /* Green for success */
            --success-color-darker: #218838;
            --warning-color: #f1c40f;
            --info-color: #3498db;

            --border-color: #DEE6F0;
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 12px;
            
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 8px 20px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-sans-serif);
            line-height: 1.6;
            background-color: var(--background-color);
            color: var(--text-color-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2.5rem; /* Increased margin */
            padding-bottom: 1.5rem; /* Increased padding */
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--text-color-primary);
            font-size: 2.2rem; /* Slightly adjusted */
            font-weight: 600;
            flex-grow: 1;
            text-align: center; /* Default to center */
            margin: 0 1rem; /* Spacing from potential side buttons */
        }
        
        /* If h1 is the first direct child and there's content after it (like a button) */
        header > h1:first-child:not(:last-child) {
            text-align: left; /* Align left if there's a button on the right */
            margin-left: 0;
        }
        /* If h1 is the last direct child and there's content before it */
        header > h1:last-child:not(:first-child) {
            text-align: right; /* Align right if there's a button on the left */
             margin-right: 0;
        }
        /* If h1 is the only child, or between two elements, center is fine */


        .btn-add, .btn-action { /* Common base for primary action buttons */
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.8rem 1.6rem; /* Slightly larger padding */
            border: none;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
            font-size: 0.95rem;
            box-shadow: var(--shadow-sm);
            white-space: nowrap;
        }

        .btn-add { /* Primary "add" button style */
            background-color: var(--accent-color);
            color: white;
        }

        .btn-add:hover {
            background-color: var(--accent-color-darker);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .btn-action.secondary { /* For "Back to Categories" */
            background-color: var(--text-color-secondary);
            color: white;
        }
        .btn-action.secondary:hover {
            background-color: #5a6268; /* Darken secondary */
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }


        .notes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(330px, 1fr)); /* Slightly larger minmax */
            gap: 2rem; /* Increased gap */
        }

        /* Card Base Styles (for Category and Note) */
        .card-base {
            background: var(--card-background-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
            display: flex;
            flex-direction: column;
        }

        .card-base:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }

        /* Category Card Styles */
        .category-card {
            /* Extends .card-base implicitly through class list */
        }

        .category-header {
            padding: 1rem 1.25rem; /* Adjusted padding */
            background-color: #F8F9FA; /* Lighter header bg */
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
        }

        .category-name {
            font-size: 1.2rem; /* Increased size */
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            padding: 0.5rem 0.75rem; 
            border: 1px solid transparent; 
            border-radius: var(--border-radius-sm);
            background-color: transparent;
            outline: none;
            transition: background-color 0.2s, border-color 0.2s;
            min-width: 0; /* Allow input to shrink below its content size */
        }
        .category-name:not([readonly]) {
            border: 1px solid var(--accent-color);
            background-color: var(--card-background-color);
            box-shadow: 0 0 0 2px rgba(var(--accent-color-rgb, 74, 144, 226), 0.2); /* Define --accent-color-rgb if not already */
        }
        .category-name[readonly]:hover {
            cursor: text;
            background-color: rgba(0,0,0,0.04);
        }


        .category-body {
            padding: 1.5rem; /* Increased padding */
            display: flex;
            justify-content: center; 
            align-items: center;
            flex-grow: 1; /* Ensure body takes up space if header is small */
        }

        .btn-open-category {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.7rem 1.4rem; 
            background-color: var(--text-color-secondary); /* MODIFIED: Changed to gray */
            color: white;
            border: none;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
        }

        .btn-open-category:hover {
            background-color: #5a6268; /* MODIFIED: Darker gray for hover, matches secondary button hover */
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .category-actions, .note-actions { /* Shared group for action buttons */
            display: flex;
            gap: 0.35rem; 
            flex-shrink: 0; /* Prevent action groups from shrinking and hiding buttons */
        }

        /* Note Card Styles */
        .note {
             /* Extends .card-base implicitly through class list */
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem; /* Adjusted padding */
            background-color: #FDFEFE; /* Very light, almost white */
            border-bottom: 1px solid var(--border-color);
        }

        .note-date {
            font-size: 0.8rem;
            color: var(--text-color-secondary);
            font-weight: 500;
        }

        .note-btn { /* Icon buttons in card headers */
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0.5rem; /* Increased padding for touch */
            color: var(--text-color-secondary);
            transition: all 0.2s ease;
            border-radius: 50%; /* Circular icon buttons */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .note-btn:hover {
            background-color: #E9ECEF; /* Light hover for icon buttons */
            color: var(--text-color-primary);
        }

        .note-btn.locked {
            color: var(--danger-color);
        }
        .note-btn.locked:hover {
            background-color: rgba(231, 76, 60, 0.1);
        }

        .note-btn.delete-btn:hover {
            background-color: rgba(220, 53, 69, 0.1); /* Lighter red for delete hover */
            color: var(--danger-color-darker);
        }
        .material-icons.md-18 { font-size: 20px; } /* Slightly larger small icons */


        .note-title, .note-content {
            width: 100%;
            padding: 1.25rem; /* Consistent padding */
            border: none;
            background-color: var(--card-background-color);
            font-family: inherit;
            color: var(--text-color-primary);
        }
        
        .note-title {
            font-size: 1.15rem;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
        }

        .note-content {
            min-height: 180px; /* Ensure decent default height */
            resize: vertical; /* Allow vertical resize only */
            font-size: 1rem;
            line-height: 1.5;
        }

        .note-title:focus, .note-content:focus {
            outline: none;
            background-color: #fdfdfd; /* Very subtle focus background */
            box-shadow: inset 0 0 0 2px var(--accent-color); /* Inner focus ring */
        }
        
        .note-title.locked,
        .note-content.locked {
            background-color: #F8F9FA; /* Slightly off-white for locked */
            cursor: not-allowed;
            color: var(--text-color-secondary);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 2.5rem; /* Increased bottom spacing */
            left: 50%;
            transform: translateX(-50%) translateY(120px); /* Start further down */
            background-color: var(--text-color-primary); /* Darker toast */
            color: white;
            padding: 0.8rem 1.6rem;
            border-radius: var(--border-radius-md);
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s ease; /* Smoother transition */
            box-shadow: var(--shadow-lg);
            z-index: 2000; /* Ensure toast is above dialogs */
            font-size: 0.9rem;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .material-icons {
            font-size: 22px; /* Default icon size */
            vertical-align: middle; /* Better alignment with text */
        }
        
        .empty-state-message {
            text-align: center; 
            color: var(--text-color-secondary); 
            grid-column: 1 / -1; 
            padding: 3rem 1rem; /* More padding */
            font-size: 1.1rem;
            font-style: italic;
            background-color: var(--card-background-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .notes-grid {
                grid-template-columns: 1fr; /* Single column on smaller screens */
                gap: 1.5rem;
            }
            
            h1 {
                font-size: 1.8rem; 
            }
            header {
                flex-wrap: wrap; 
                gap: 1rem; /* Gap when items wrap */
                padding-bottom: 1rem;
                margin-bottom: 2rem;
            }
            header > h1 { /* When header wraps, title usually goes first */
                text-align: center !important; /* Force center on mobile if wrapped */
                width: 100%; 
                order: -1; /* Title first */
                margin: 0 0 0.5rem 0 !important; /* Adjust margin for wrapped title */
            }
            header > button, header > .btn-action { /* Buttons take full width or stack if needed */
                flex-grow: 1; /* Allow buttons to grow if space */
                min-width: 150px; /* Prevent buttons from becoming too small */
            }
            /* Ensure back button and add note button are spaced in notes view on mobile */
            #notesView header {
                justify-content: center; /* Center buttons when wrapped */
            }
             #notesView header > #backToCategoriesBtn { order: 0; }
             #notesView header > #addNoteToCategoryBtn { order: 1; }


            .btn-add, .btn-action {
                padding: 0.7rem 1.2rem;
                font-size: 0.9rem;
            }
            
            /* MODIFIED: Category Card adjustments for mobile */
            .category-header {
                gap: 0.5rem; /* Reduce gap between name and actions */
                padding: 0.75rem 1rem; /* Slightly adjust padding */
            }
            .category-name {
                /* flex-grow: 1; already set */
                flex-shrink: 1; /* Allow category name to shrink if needed */
                /* min-width: 0; already set globally */
                font-size: 1.1rem; /* Slightly smaller font for category name on mobile if needed */
            }
            .category-actions {
                /* flex-shrink: 0; already set globally */
                gap: 0.2rem; /* Tighter gap for icon buttons on mobile (already here, kept for clarity) */
            }
            .category-body {
                padding: 2.5rem 1.5rem; /* MODIFIED: Increased vertical padding for taller card */
            }
            /* End of category card adjustments */

            .note-actions {
                gap: 0.2rem; /* Tighter gap for icon buttons on mobile (already here, kept for clarity) */
            }
            
            .note-btn {
                padding: 0.4rem; /* Slightly smaller padding for icon buttons on mobile */
            }
            .material-icons {
                 font-size: 20px; /* Slightly smaller icons on mobile */
            }
        }
        /* --- END OF style.css --- */
    </style>
</head>
<body>
    <div class="container">
        <!-- Content will be dynamically inserted here by main.js -->
    </div>
    <div id="toast" class="toast"></div>

    <script type="module">
        // --- START OF toastUtils.js ---
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000); // Slightly longer duration for better readability
        }
        // --- END OF toastUtils.js ---

        // --- START OF clipboardUtils.js ---
        function copyToClipboard(text) {
            if (!text) {
                showToast('Nothing to copy!');
                return;
            }
            navigator.clipboard.writeText(text)
                .then(() => {
                    showToast('Copied to clipboard!');
                })
                .catch(err => {
                    showToast('Failed to copy text.');
                    console.error('Clipboard copy failed:', err);
                });
        }
        // --- END OF clipboardUtils.js ---

        // --- START OF dateUtils.js ---
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric',
                // hour: '2-digit', // Optional: add time
                // minute: '2-digit'
            });
        }
        // --- END OF dateUtils.js ---

        // --- START OF dialog.js ---
        class DialogManager {
          constructor() {
            this.init();
          }

          init() {
            const style = document.createElement('style');
            // Using CSS variables from the main stylesheet
            style.textContent = `
              .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.65); /* Slightly darker overlay */
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1001; /* Above most content, below toast */
                opacity: 0;
                transition: opacity 0.25s ease-in-out;
              }

              .dialog-overlay.visible {
                opacity: 1;
              }

              .dialog-container {
                background: var(--card-background-color, white);
                border-radius: var(--border-radius-lg, 12px);
                padding: 28px; /* Increased padding */
                max-width: 420px; /* Slightly wider */
                width: 90%;
                transform: translateY(-20px) scale(0.95);
                transition: transform 0.25s ease-in-out, opacity 0.25s ease-in-out;
                box-shadow: var(--shadow-lg, 0 8px 20px rgba(0,0,0,0.1));
                opacity: 0;
              }

              .dialog-overlay.visible .dialog-container {
                transform: translateY(0) scale(1);
                opacity: 1;
              }

              .dialog-title {
                font-size: 1.4em; /* Larger title */
                font-weight: 600;
                margin: 0 0 18px 0; 
                color: var(--text-color-primary, #333);
              }

              .dialog-message {
                margin: 0 0 24px 0;
                color: var(--text-color-secondary, #555);
                line-height: 1.6;
                font-size: 1em;
              }
              
              .dialog-input {
                width: 100%;
                padding: 12px 14px;
                margin-bottom: 24px;
                border: 1px solid var(--border-color, #ccc);
                border-radius: var(--border-radius-md, 6px);
                font-size: 1em;
                font-family: var(--font-family-sans-serif);
                color: var(--text-color-primary);
                background-color: var(--card-background-color);
              }
              .dialog-input:focus {
                outline: none;
                border-color: var(--accent-color, #007bff);
                box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb, 74, 144, 226), 0.25);
              }


              .dialog-buttons {
                display: flex;
                justify-content: flex-end;
                gap: 12px;
              }

              .dialog-btn {
                padding: 10px 20px; 
                border-radius: var(--border-radius-md, 6px);
                border: none;
                cursor: pointer;
                font-size: 0.95em;
                font-weight: 500;
                transition: all 0.2s;
              }

              .dialog-btn:hover {
                transform: translateY(-1px);
                filter: brightness(0.9);
              }

              .dialog-btn-confirm {
                background-color: var(--danger-color, #e74c3c); 
                color: white;
              }
              .dialog-btn-confirm.info { background-color: var(--info-color, #3498db); }
              .dialog-btn-confirm.warning { background-color: var(--warning-color, #f1c40f); color: var(--text-color-primary, #333); }
              .dialog-btn-confirm.primary { background-color: var(--accent-color, #007bff); color: white; }


              .dialog-btn-cancel {
                background-color: #ECF0F1; /* Light grey */
                color: var(--text-color-secondary, #2c3e50);
                border: 1px solid var(--border-color, #ddd);
              }
              .dialog-btn-cancel:hover {
                background-color: #E0E6E8;
              }
            `;
            // Helper to parse RGB from hex for box-shadow alpha
            const accentColorHex = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
            if (accentColorHex) {
                const rgb = accentColorHex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                if (rgb) {
                    const r = parseInt(rgb[1], 16);
                    const g = parseInt(rgb[2], 16);
                    const b = parseInt(rgb[3], 16);
                    document.documentElement.style.setProperty('--accent-color-rgb', `${r}, ${g}, ${b}`);
                }
            }
            document.head.appendChild(style);
          }

          confirm(options = {}) {
            const {
              title = 'Confirm',
              message = 'Are you sure?',
              confirmText = 'Confirm',
              cancelText = 'Cancel',
              type = 'danger' // 'danger', 'info', 'warning', 'primary'
            } = options;

            return new Promise((resolve) => {
              const overlay = document.createElement('div');
              overlay.className = 'dialog-overlay';
              
              overlay.innerHTML = `
                <div class="dialog-container">
                  <h3 class="dialog-title">${title}</h3>
                  <p class="dialog-message">${message}</p>
                  <div class="dialog-buttons">
                    <button class="dialog-btn dialog-btn-cancel">${cancelText}</button>
                    <button class="dialog-btn dialog-btn-confirm">${confirmText}</button>
                  </div>
                </div>
              `;
              
              const confirmButton = overlay.querySelector('.dialog-btn-confirm');
              if (type) { confirmButton.classList.add(type); }


              const closeDialog = (result) => {
                overlay.classList.remove('visible');
                overlay.querySelector('.dialog-container').style.opacity = '0';
                setTimeout(() => {
                  overlay.remove();
                  resolve(result);
                }, 250); 
              };

              overlay.querySelector('.dialog-btn-confirm').addEventListener('click', () => closeDialog(true));
              overlay.querySelector('.dialog-btn-cancel').addEventListener('click', () => closeDialog(false));
              
              const handleEsc = (e) => {
                if (e.key === 'Escape') {
                  closeDialog(false);
                  window.removeEventListener('keydown', handleEsc);
                }
              };
              window.addEventListener('keydown', handleEsc);
              
              overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                   closeDialog(false);
                   window.removeEventListener('keydown', handleEsc);
                }
              });

              document.body.appendChild(overlay);
              requestAnimationFrame(() => { // Ensure element is in DOM before adding class
                overlay.classList.add('visible');
              });
            });
          }

          prompt(options = {}) {
            const {
              title = 'Input Required',
              message = '',
              placeholder = '',
              confirmText = 'OK',
              cancelText = 'Cancel',
              initialValue = '',
              type = 'primary' // For confirm button color
            } = options;
        
            return new Promise((resolve) => {
              const overlay = document.createElement('div');
              overlay.className = 'dialog-overlay';
              
              overlay.innerHTML = `
                <div class="dialog-container">
                  <h3 class="dialog-title">${title}</h3>
                  ${message ? `<p class="dialog-message">${message}</p>` : ''}
                  <input type="text" class="dialog-input" placeholder="${placeholder}" value="${initialValue}">
                  <div class="dialog-buttons">
                    <button class="dialog-btn dialog-btn-cancel">${cancelText}</button>
                    <button class="dialog-btn dialog-btn-confirm">${confirmText}</button>
                  </div>
                </div>
              `;
        
              const inputField = overlay.querySelector('.dialog-input');
              const confirmButton = overlay.querySelector('.dialog-btn-confirm');
              if (type) { confirmButton.classList.add(type); }

              let closed = false; // Prevent double resolution
              const closeDialog = (value) => {
                if (closed) return;
                closed = true;
                overlay.classList.remove('visible');
                overlay.querySelector('.dialog-container').style.opacity = '0';
                window.removeEventListener('keydown', handleEsc);
                setTimeout(() => {
                  overlay.remove();
                  resolve(value);
                }, 250); 
              };
        
              confirmButton.addEventListener('click', () => closeDialog(inputField.value)); // Return value, trim later
              overlay.querySelector('.dialog-btn-cancel').addEventListener('click', () => closeDialog(null));
              
              inputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                  e.preventDefault();
                  closeDialog(inputField.value); // Return value, trim later
                }
              });
              
              const handleEsc = (e) => {
                if (e.key === 'Escape') {
                  closeDialog(null);
                }
              };
              window.addEventListener('keydown', handleEsc);
              
              overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                   closeDialog(null);
                }
              });
        
              document.body.appendChild(overlay);
              requestAnimationFrame(() => {
                 overlay.classList.add('visible');
                 inputField.focus();
                 inputField.select();
              });
            });
          }
        }
        // --- END OF dialog.js ---

        // --- START OF LibraryManager.js ---
        class LibraryManager {
            constructor() {
                this.categories = JSON.parse(localStorage.getItem('libraryCategories')) || [];
            }

            // Category Methods
            addCategory(name = 'New Category') {
                const category = {
                    id: `cat_${Date.now()}`,
                    name: name,
                    notes: [],
                    createdAt: new Date().toISOString()
                };
                this.categories.unshift(category);
                this.saveToLocalStorage();
                return category;
            }

            updateCategoryName(categoryId, newName) {
                const category = this.categories.find(cat => cat.id === categoryId);
                if (category) {
                    category.name = newName;
                    this.saveToLocalStorage();
                }
            }

            deleteCategory(categoryId) {
                this.categories = this.categories.filter(cat => cat.id !== categoryId);
                this.saveToLocalStorage();
            }

            moveCategory(categoryId, direction) {
                const index = this.categories.findIndex(cat => cat.id === categoryId);
                if (index === -1) return false;
                
                const newIndex = direction === 'up' ? index - 1 : index + 1;
                if (newIndex >= 0 && newIndex < this.categories.length) {
                    const cat = this.categories[index];
                    this.categories.splice(index, 1);
                    this.categories.splice(newIndex, 0, cat);
                    this.saveToLocalStorage();
                    return true;
                }
                return false;
            }

            getCategory(categoryId) {
                return this.categories.find(cat => cat.id === categoryId);
            }

            // Note Methods
            addNoteToCategory(categoryId) {
                const category = this.getCategory(categoryId);
                if (!category) return null;

                const note = {
                    id: `note_${Date.now()}`,
                    title: '',
                    content: '',
                    isLocked: false,
                    createdAt: new Date().toISOString()
                };
                category.notes.unshift(note);
                this.saveToLocalStorage();
                return note;
            }

            updateNoteInCategory(categoryId, noteId, updates) {
                const category = this.getCategory(categoryId);
                if (!category) return;
                const note = category.notes.find(n => n.id === noteId);
                if (note && !note.isLocked) {
                    Object.assign(note, updates);
                    this.saveToLocalStorage();
                }
            }

            deleteNoteFromCategory(categoryId, noteId) {
                const category = this.getCategory(categoryId);
                if (!category) return;
                category.notes = category.notes.filter(n => n.id !== noteId);
                this.saveToLocalStorage();
            }

            moveNoteInCategory(categoryId, noteId, direction) {
                const category = this.getCategory(categoryId);
                if (!category) return false;
                const index = category.notes.findIndex(n => n.id === noteId);
                if (index === -1) return false;

                const newIndex = direction === 'up' ? index - 1 : index + 1;
                if (newIndex >= 0 && newIndex < category.notes.length) {
                    const note = category.notes[index];
                    category.notes.splice(index, 1);
                    category.notes.splice(newIndex, 0, note);
                    this.saveToLocalStorage();
                    return true;
                }
                return false;
            }

            toggleNoteLockInCategory(categoryId, noteId) {
                const category = this.getCategory(categoryId);
                if (!category) return;
                const note = category.notes.find(n => n.id === noteId);
                if (note) {
                    note.isLocked = !note.isLocked;
                    this.saveToLocalStorage();
                }
            }
            
            getNoteFromCategory(categoryId, noteId) {
                const category = this.getCategory(categoryId);
                if (!category) return null;
                return category.notes.find(n => n.id === noteId) || null;
            }

            saveToLocalStorage() {
                localStorage.setItem('libraryCategories', JSON.stringify(this.categories));
            }
        }
        // --- END OF LibraryManager.js ---

        const dialog = new DialogManager();
        const libraryManager = new LibraryManager();

        let currentView = 'categories';
        let currentCategoryId = null;
        let appContainer, categoriesViewDiv, notesViewDiv, categoriesGrid, notesContainerInView;


        // --- START OF categoryElement.js ---
        function createCategoryElement(category, onCategoriesUpdateCallback) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'category-card card-base'; // Added card-base
            cardDiv.dataset.categoryId = category.id;

            cardDiv.innerHTML = `
                <div class="category-header">
                    <input type="text" class="category-name" value="${category.name}" title="Click to edit name" readonly>
                    <div class="category-actions">
                        <button class="note-btn" data-action="moveCatUp" title="Move category up">
                            <span class="material-icons md-18">arrow_upward</span>
                        </button>
                        <button class="note-btn" data-action="moveCatDown" title="Move category down">
                            <span class="material-icons md-18">arrow_downward</span>
                        </button>
                        <button class="note-btn delete-btn" data-action="deleteCat" title="Delete category">
                            <span class="material-icons md-18">delete_sweep</span>
                        </button>
                    </div>
                </div>
                <div class="category-body">
                    <button class="btn-open-category" data-action="openCat">
                        <span class="material-icons">folder_open</span>
                        Open This
                    </button>
                </div>
            `; // MODIFIED: Button text changed to "Open This"

            const categoryNameInput = cardDiv.querySelector('.category-name');
            
            const enableEdit = () => {
                if (categoryNameInput.readOnly) {
                    categoryNameInput.readOnly = false;
                    categoryNameInput.focus();
                    categoryNameInput.select();
                }
            };
            categoryNameInput.addEventListener('click', enableEdit);

            const saveEdit = () => {
                categoryNameInput.readOnly = true;
                const newName = categoryNameInput.value.trim();
                if (newName && newName !== category.name) {
                    libraryManager.updateCategoryName(category.id, newName);
                    showToast(`Category renamed to "${newName}".`);
                } else {
                    categoryNameInput.value = category.name; 
                }
            };
            categoryNameInput.addEventListener('blur', saveEdit);
            categoryNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); 
                    categoryNameInput.blur();
                } else if (e.key === 'Escape') {
                    categoryNameInput.value = category.name; 
                    categoryNameInput.blur();
                }
            });

            cardDiv.querySelectorAll('.category-actions button, .category-body button').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent card hover effects from triggering if button click changes state quickly
                    const action = btn.dataset.action;
                    switch(action) {
                        case 'openCat':
                            switchView('notes', category.id);
                            break;
                        case 'moveCatUp':
                            if(libraryManager.moveCategory(category.id, 'up')) onCategoriesUpdateCallback();
                            else showToast("Already at the top.");
                            break;
                        case 'moveCatDown':
                            if(libraryManager.moveCategory(category.id, 'down')) onCategoriesUpdateCallback();
                            else showToast("Already at the bottom.");
                            break;
                        case 'deleteCat':
                            const confirmed = await dialog.confirm({
                                title: 'Delete Category',
                                message: `Delete category "${category.name}" and ALL its notes? This action is irreversible.`,
                                confirmText: 'Delete All',
                                type: 'danger'
                            });
                            if (confirmed) {
                                libraryManager.deleteCategory(category.id);
                                onCategoriesUpdateCallback();
                                showToast(`Category "${category.name}" deleted.`);
                            }
                            break;
                    }
                });
            });
            return cardDiv;
        }
        // --- END OF categoryElement.js ---

        // --- START OF noteElement.js ---
        function createNoteElement(note, categoryIdForNote, onNoteUpdateCallback) {
            const noteDiv = document.createElement('div');
            noteDiv.className = 'note card-base'; // Added card-base
            noteDiv.dataset.noteId = note.id;
            noteDiv.innerHTML = `
                <div class="note-header">
                    <div class="note-date">${formatDate(note.createdAt)}</div>
                    <div class="note-actions">
                        <button class="note-btn" data-action="moveUp" title="Move up">
                            <span class="material-icons">arrow_upward</span>
                        </button>
                        <button class="note-btn" data-action="moveDown" title="Move down">
                            <span class="material-icons">arrow_downward</span>
                        </button>
                        <button class="note-btn" data-action="copy" title="Copy note content">
                            <span class="material-icons">content_copy</span>
                        </button>
                        <button class="note-btn ${note.isLocked ? 'locked' : ''}" data-action="lock" title="${note.isLocked ? 'Unlock' : 'Lock'} note">
                            <span class="material-icons">${note.isLocked ? 'lock' : 'lock_open'}</span>
                        </button>
                        <button class="note-btn delete-btn" data-action="delete" title="Delete note">
                            <span class="material-icons">delete</span>
                        </button>
                    </div>
                </div>
                <input type="text" 
                    class="note-title ${note.isLocked ? 'locked' : ''}"
                    placeholder="Note Title"
                    value="${note.title || ''}"
                    ${note.isLocked ? 'readonly' : ''}
                    aria-label="Note Title"
                >
                <textarea
                    class="note-content ${note.isLocked ? 'locked' : ''}"
                    placeholder="Write your note here..." spellcheck="false" 
                    ${note.isLocked ? 'readonly' : ''}
                    aria-label="Note Content"
                >${note.content || ''}</textarea>
            `;

            setupNoteEventListeners(noteDiv, note, categoryIdForNote, onNoteUpdateCallback);
            return noteDiv;
        }

        function setupNoteEventListeners(noteDiv, note, categoryIdForNote, onNoteUpdateCallback) {
            const titleInput = noteDiv.querySelector('.note-title');
            const textarea = noteDiv.querySelector('.note-content');
            const lockButton = noteDiv.querySelector('.note-btn[data-action="lock"]');

            titleInput.addEventListener('input', () => {
                if (!note.isLocked) { // Note object might be stale, re-fetch or rely on UI state
                    libraryManager.updateNoteInCategory(categoryIdForNote, note.id, { title: titleInput.value });
                }
            });
            textarea.addEventListener('input', () => {
                 if (!note.isLocked) { // As above
                    libraryManager.updateNoteInCategory(categoryIdForNote, note.id, { content: textarea.value });
                }
            });

            noteDiv.querySelectorAll('.note-actions .note-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    // Pass the most current note object by fetching it, or ensure isLocked state is accurate
                    const currentNoteState = libraryManager.getNoteFromCategory(categoryIdForNote, note.id) || note;
                    handleNoteAction(action, currentNoteState, categoryIdForNote, noteDiv, titleInput, textarea, btn, onNoteUpdateCallback);
                });
            });
        }

        function handleNoteAction(action, note, categoryIdForNote, noteDiv, titleInput, textarea, btn, onNoteUpdateCallback) {
            switch(action) {
                case 'copy':
                    copyToClipboard(textarea.value);
                    break;
                case 'lock':
                    handleLockToggle(note, categoryIdForNote, titleInput, textarea, btn);
                    break;
                case 'delete':
                    handleDelete(note, categoryIdForNote, noteDiv, onNoteUpdateCallback);
                    break;
                case 'moveUp':
                case 'moveDown':
                    if(libraryManager.moveNoteInCategory(categoryIdForNote, note.id, action === 'moveUp' ? 'up' : 'down')) {
                        onNoteUpdateCallback(categoryIdForNote); 
                    } else {
                        showToast(action === 'moveUp' ? "Already at the top." : "Already at the bottom.");
                    }
                    break;
            }
        }

        function handleLockToggle(note, categoryIdForNote, titleInput, textarea, btn) {
            libraryManager.toggleNoteLockInCategory(categoryIdForNote, note.id);
            // Fetch the updated note to get the correct lock state
            const updatedNote = libraryManager.getNoteFromCategory(categoryIdForNote, note.id); 
            if (!updatedNote) return; // Should not happen

            [titleInput, textarea].forEach(el => {
                el.classList.toggle('locked', updatedNote.isLocked);
                el.readOnly = updatedNote.isLocked;
            });
            btn.classList.toggle('locked', updatedNote.isLocked);
            btn.querySelector('.material-icons').textContent = updatedNote.isLocked ? 'lock' : 'lock_open';
            btn.title = updatedNote.isLocked ? 'Unlock note' : 'Lock note';
            showToast(updatedNote.isLocked ? 'Note locked.' : 'Note unlocked.');
        }

        async function handleDelete(note, categoryIdForNote, noteDiv, onNoteUpdateCallback) {
            const confirmed = await dialog.confirm({
                title: 'Delete Note',
                message: `Are you sure you want to delete the note titled "${note.title || 'Untitled Note'}"?`,
                confirmText: 'Delete',
                type: 'danger'
            });

            if (confirmed) {
                libraryManager.deleteNoteFromCategory(categoryIdForNote, note.id);
                noteDiv.remove(); 
                showToast('Note deleted.');
                if (notesContainerInView.children.length === 0) {
                   onNoteUpdateCallback(categoryIdForNote); 
                }
            }
        }
        // --- END OF noteElement.js ---

        // --- START OF main.js ---
        function initAppStructure() {
            appContainer = document.querySelector('.container');
            appContainer.innerHTML = ''; 

            categoriesViewDiv = document.createElement('div');
            categoriesViewDiv.id = 'categoriesView';
            categoriesViewDiv.innerHTML = `
                <header>
                    <h1>My Library</h1>
                    <button id="addCategoryBtn" class="btn-add">
                        <span class="material-icons">create_new_folder</span>
                        New Category
                    </button>
                </header>
                <div id="categoriesGrid" class="notes-grid"></div>
            `;
            appContainer.appendChild(categoriesViewDiv);
            categoriesGrid = categoriesViewDiv.querySelector('#categoriesGrid');

            notesViewDiv = document.createElement('div');
            notesViewDiv.id = 'notesView';
            notesViewDiv.innerHTML = `
                <header>
                    <button id="backToCategoriesBtn" class="btn-action secondary">
                        <span class="material-icons">arrow_back</span>
                        Categories
                    </button>
                    <h1 id="notesViewTitle">Category Notes</h1>
                    <button id="addNoteToCategoryBtn" class="btn-add">
                        <span class="material-icons">note_add</span>
                        New Note
                    </button>
                </header>
                <div id="notesContainerInView" class="notes-grid"></div>
            `;
            appContainer.appendChild(notesViewDiv);
            notesContainerInView = notesViewDiv.querySelector('#notesContainerInView');

            document.getElementById('addCategoryBtn').addEventListener('click', async () => {
                const newCategoryNameResult = await dialog.prompt({
                    title: 'Create New Category',
                    message: 'Enter a name for your new category:',
                    placeholder: 'E.g., Work Projects, Personal Ideas',
                    confirmText: 'Create Category',
                    type: 'primary'
                });

                if (newCategoryNameResult !== null) { // User didn't cancel
                    const trimmedName = newCategoryNameResult.trim();
                    if (trimmedName) {
                        libraryManager.addCategory(trimmedName);
                        renderCategories();
                        showToast(`Category "${trimmedName}" added.`);
                    } else {
                        showToast("Category name cannot be empty.");
                    }
                }
            });

            document.getElementById('backToCategoriesBtn').addEventListener('click', () => {
                switchView('categories');
            });

            document.getElementById('addNoteToCategoryBtn').addEventListener('click', () => {
                if (currentCategoryId) {
                    const note = libraryManager.addNoteToCategory(currentCategoryId);
                    if (note) {
                        if (notesContainerInView.querySelector('.empty-state-message')) {
                            notesContainerInView.innerHTML = '';
                        }
                        const noteElement = createNoteElement(note, currentCategoryId, renderNotesForCategory);
                        notesContainerInView.insertBefore(noteElement, notesContainerInView.firstChild);
                        showToast('New note added.');
                        const newTitleInput = noteElement.querySelector('.note-title');
                        if (newTitleInput) newTitleInput.focus();
                    }
                }
            });
        }

        function switchView(view, categoryId = null) {
            currentView = view;
            currentCategoryId = categoryId;

            if (view === 'categories') {
                categoriesViewDiv.style.display = 'block';
                notesViewDiv.style.display = 'none';
                document.title = "Library - Categories";
                renderCategories();
            } else if (view === 'notes' && categoryId) {
                categoriesViewDiv.style.display = 'none';
                notesViewDiv.style.display = 'block';
                const category = libraryManager.getCategory(categoryId);
                const categoryName = category ? category.name : 'Unknown Category';
                document.getElementById('notesViewTitle').textContent = `${categoryName}`;
                document.title = `Notes - ${categoryName}`;
                renderNotesForCategory(categoryId);
            }
        }

        function renderCategories() {
            categoriesGrid.innerHTML = '';
            const categories = libraryManager.categories;
            if (categories.length === 0) {
                categoriesGrid.innerHTML = '<p class="empty-state-message">No categories yet. Click "New Category" to get started!</p>';
            } else {
                categories.forEach(category => {
                    categoriesGrid.appendChild(createCategoryElement(category, renderCategories));
                });
            }
        }

        function renderNotesForCategory(categoryIdForRender) {
            notesContainerInView.innerHTML = '';
            const category = libraryManager.getCategory(categoryIdForRender);
            if (!category) {
                notesContainerInView.innerHTML = '<p class="empty-state-message">Category not found. It might have been deleted.</p>';
                return;
            }
            if (category.notes.length === 0) {
                notesContainerInView.innerHTML = '<p class="empty-state-message">This category is empty. Click "New Note" to add your first note!</p>';
                return;
            }
            category.notes.forEach(note => {
                notesContainerInView.appendChild(createNoteElement(note, categoryIdForRender, renderNotesForCategory));
            });
        }

        initAppStructure();
        switchView('categories'); 
        // --- END OF main.js ---
    </script>

    <script>
      // Service Worker Registration:
      // The file 'sw.js' must be created and placed in the same directory as this HTML file.
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then(registration => {
              console.log('Service Worker registered successfully. Scope:', registration.scope);
            })
            .catch(error => {
              console.log('Service Worker registration failed:', error);
            });
        });
      }
    </script>
</body>
</html>